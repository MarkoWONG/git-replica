#!/bin/dash
# Written by Marko Wong (z5309371)
# Girt-checkout switches branches.

# Error check: There must be an existing .girt repository
if [ -d .girt ]
then 
    :
else 
    echo "girt-checkout: error: girt repository directory .girt not found"
    exit 1;
fi

# Error check: There must be an existing commit
if [ -d .girt/commit_0 ]
then
    :
else
    echo "girt-checkout: error: this command can not be run until after the first commit"
    exit 1;
fi

# Error check: There can be only one agrument
if [ $# -eq 1 ]
then
    # Check if argument is a valid branch
    if [ -d .girt/branches/"$1" ]
    then
        :
    else 
        echo "girt-checkout: error: unknown branch '"$1"'";
        exit 1;
    fi
else
    echo "usage: girt-checkout <branch>"
    exit 1;
fi

# Extract the current working branch(cwb)
cwb=$(cat .girt/branches/current_working_branch.txt);

# Copy all files in cwd to cwb and new_b (saving work done on the branch)
for current_files in ./*
do
    if [ -f "$current_files" ]
    then
        current_file_name=$(basename "$branch_files");
        #echo "copying "$current_files" to .girt/branches/"$cwb"/"$current_file_name"";
        cp "$current_files" .girt/branches/"$cwb"/"$current_file_name";

        cp "$current_files" .girt/branches/"$1"/"$current_file_name";
    fi
done

# Added the commits done on cwb to cwb
cd .girt;
for commit_file in *
do
    #echo "commit file is "$commit_file""
    commit_owner=$(cat commit_3/commit_owner)
    if [ -d "$commit_file" ] && echo "$commit_file" | egrep -q '^commit_.*' &&
    then 
        cp -R "$commit_file" branches/"$cwb";
    fi
done
cd ..;

#copies all files in switching to branch to cwd
for b_file in .girt/branches/"$1"/*
do
    if [ -f "$b_file" ]
    then
        b_file_name=$(basename "$b_file");
        cp "$b_file" ./"$b_file_name";
    fi
done

# Calculate the latest commit number for the branch we are switching from
commit_no=0;
while [ -d ".girt/branches/"$cwb"/commit_"$commit_no"" ] 
do
    commit_no=$(( $commit_no + 1 ));
done
latest_cwb_commit_no=$(( $commit_no - 1 ));

# Calculate the latest commit number for the branch we are switching to
commit_no=0;
while [ -d ".girt/branches/"$1"/commit_"$commit_no"" ] 
do
    commit_no=$(( $commit_no + 1 ));
done
latest_new_b_commit_no=$(( $commit_no - 1 ));
echo "branches are different "$cwb"="$latest_cwb_commit_no" vs "$1"="$latest_new_b_commit_no""

# if branches contain different commits then
if [ "$latest_new_b_commit_no" -ne "$latest_cwb_commit_no" ]
then 
    echo "branches are different "$cwb"="$latest_cwb_commit_no" vs "$1"="$latest_new_b_commit_no""
    for new_b_file in .girt/commit_"$latest_new_b_commit_no"/*
    do
        #echo "new_b_file is "$new_b_file""
        new_b_file_name=$(basename "$new_b_file");
        if [ -f "$new_b_file" ] && [ "$new_b_file_name" != "commit_message.txt" ]
        then 
            #overwrite file with new_b_commit
            echo ""$new_b_file" --> ./"$new_b_file_name""; 
            cp "$new_b_file" ./"$new_b_file_name"
        fi 
    done

    #remove files in cwb commit but not in new_b_commit
    for cwb_file in .girt/commit_"$latest_cwb_commit_no"/*
    do 
        cwb_file_name=$(basename "$cwb_file");
        if [ -f .girt/commit_"$latest_new_b_commit_no"/"$cwb_file_name" ]
        then 
            :
        elif [ -f "$cwb_file" ]
        then
            #echo "removed ./"$cwb_file_name"";
            rm ./"$cwb_file_name";
        fi 
    done
fi

echo "$1" > .girt/branches/current_working_branch.txt;
echo "Switched to branch '"$1"'";
exit 0;